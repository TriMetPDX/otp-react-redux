{"version":3,"sources":["geocoder.js"],"names":["Geocoder","geocoderApi","geocoderConfig","api","query","autocomplete","getAutocompleteQuery","then","rewriteAutocompleteResponse","feature","location","lonlat","fromCoordinates","geometry","coordinates","name","properties","label","Promise","resolve","reverse","getReverseQuery","rewriteReverseResponse","search","getSearchQuery","rewriteSearchResponse","apiKey","baseUrl","boundary","focusPoint","url","undefined","format","response","ArcGISGeocoder","magicKey","text","features","filter","isCollection","map","lat","lon","NoApiGeocoder","parseCoordinateString","point","roundGPSDecimal","string","toCoordinates","fromLatFirstString","type","e","number","roundFactor","Math","round","PeliasGeocoder","sources","isomorphicMapzenSearchQuery","address","getGeocoder","arcgis","pelias","console","error"],"mappings":"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","sourcesContent":["import * as arcgis from '@conveyal/geocoder-arcgis-geojson'\nimport lonlat from '@conveyal/lonlat'\nimport * as pelias from 'isomorphic-mapzen-search'\nimport memoize from 'lodash.memoize'\n\n/**\n * Create customized geocoder functions given a certain geocoding API, the\n * config for the geocoder and response rewrite functions specific to this\n * application. Any geocoder api that is added is expected to have an API that\n * behaves very closely to https://github.com/conveyal/isomorphic-mapzen-search\n */\nclass Geocoder {\n  constructor (geocoderApi, geocoderConfig) {\n    this.api = geocoderApi\n    this.geocoderConfig = geocoderConfig\n  }\n\n  /**\n   * Perform an autocomplete query. Eg, using partial text of a possible\n   * address or POI, attempt to find possible matches.\n   */\n  autocomplete (query) {\n    return this.api.autocomplete(this.getAutocompleteQuery(query))\n      .then(this.rewriteAutocompleteResponse)\n  }\n\n  /**\n   * Get an application-specific data structure from a given feature. The\n   * feature is either the result of an autocomplete or a search query. This\n   * function returns a Promise because sometimes an asynchronous action\n   * needs to be taken to translate a feature into a location. For example,\n   * the ArcGIS autocomplete service returns results that lack full address\n   * data and GPS and it is expected that an extra call to the `search` API is\n   * done to obtain that detailed data.\n   */\n  getLocationFromGeocodedFeature (feature) {\n    const location = lonlat.fromCoordinates(feature.geometry.coordinates)\n    location.name = feature.properties.label\n    return Promise.resolve(location)\n  }\n\n  /**\n   * Do a reverse-geocode. ie get address information and attributes given a\n   * GPS coordiante.\n   */\n  reverse (query) {\n    return this.api.reverse(this.getReverseQuery(query))\n      .then(this.rewriteReverseResponse)\n  }\n\n  /**\n   * Perform a search query. A search query is different from autocomplete in\n   * that it is assumed that the text provided is more or less a complete\n   * well-fromatted address.\n   */\n  search (query) {\n    return this.api.search(this.getSearchQuery(query))\n      .then(this.rewriteSearchResponse)\n  }\n\n  /**\n   * Default autocomplete query generator\n   */\n  getAutocompleteQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      url: baseUrl ? `${baseUrl}/autocomplete` : undefined,\n      ...query\n    }\n  }\n\n  /**\n   * Default reverse query generator\n   */\n  getReverseQuery (query) {\n    const {apiKey, baseUrl} = this.geocoderConfig\n    return {\n      apiKey,\n      format: true,\n      url: baseUrl ? `${baseUrl}/reverse` : undefined,\n      ...query\n    }\n  }\n\n  /**\n   * Default search query generator.\n   */\n  getSearchQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      url: baseUrl ? `${baseUrl}/search` : undefined,\n      format: false, // keep as returned GeoJSON,\n      ...query\n    }\n  }\n\n  /**\n   * Default rewriter for autocomplete responses\n   */\n  rewriteAutocompleteResponse (response) { return response }\n\n  /**\n   * Default rewriter for reverse responses\n   */\n  rewriteReverseResponse (response) { return response }\n\n  /**\n   * Default rewriter for search responses\n   */\n  rewriteSearchResponse (response) { return response }\n}\n\n/**\n * Geocoder implementation for the ArcGIS geocoder.\n * See https://developers.arcgis.com/rest/geocode/api-reference/overview-world-geocoding-service.htm\n *\n * @extends Geocoder\n */\nclass ArcGISGeocoder extends Geocoder {\n  /**\n   * Using the given magicKey and text, perform a search query to get detailed\n   * address and GPS data. Return data in an application-specific location\n   * format.\n   */\n  getLocationFromGeocodedFeature (feature) {\n    return this.api.search({ magicKey: feature.magicKey, text: feature.text })\n      .then(response => {\n        const feature = response.features[0]\n        const location = lonlat.fromCoordinates(feature.geometry.coordinates)\n        location.name = feature.properties.label\n        return location\n      })\n  }\n\n  /**\n   * Rewrite an autocomplete response into an application specific data format.\n   * Also, filter out any results that are collections.\n   */\n  rewriteAutocompleteResponse (response) {\n    return {\n      // remove any autocomplete results that are collections\n      // (eg multiple Starbucks)\n      features: response.features.filter(feature => !feature.isCollection)\n        // add label property so location-field can handle things ok\n        .map(feature => ({\n          ...feature,\n          properties: {\n            label: feature.text\n          }\n        }))\n    }\n  }\n\n  /**\n   * Rewrite the response into an application-specific data format using the\n   * first feature returned from the geocoder.\n   */\n  rewriteReverseResponse (response) {\n    const { features, query } = response\n    const { lat, lon } = query\n    return {\n      lat,\n      lon,\n      name: features[0].properties.label\n    }\n  }\n}\n\n/**\n * An implementation that doesn't use an API for geocoding. Merely allows\n * clicking on the map and finding GPS coordinates by typing them in.\n *\n * @extends Geocoder\n */\nclass NoApiGeocoder extends Geocoder {\n  /**\n   * Use coordinate string parser.\n   */\n  autocomplete (query) {\n    return this.parseCoordinateString(query.text)\n  }\n\n  /**\n   * Always return the lat/lon.\n   */\n  reverse (query) {\n    let { lat, lon } = query.point\n    lat = this.roundGPSDecimal(lat)\n    lon = this.roundGPSDecimal(lon)\n    return Promise.resolve({ lat, lon, name: `${lat}, ${lon}` })\n  }\n\n  /**\n   * Use coordinate string parser.\n   */\n  search (query) {\n    return this.parseCoordinateString(query.text)\n  }\n\n  /**\n   * Attempt to parse the input as a GPS coordinate. If parseable, return a\n   * feature.\n   */\n  parseCoordinateString (string) {\n    let feature\n    try {\n      feature = {\n        geometry: {\n          coordinates: lonlat.toCoordinates(lonlat.fromLatFirstString(string)),\n          type: 'Point'\n        },\n        properties: {\n          label: string\n        }\n      }\n    } catch (e) {\n      return Promise.resolve({ features: [] })\n    }\n    return Promise.resolve({ features: [feature] })\n  }\n\n  roundGPSDecimal (number) {\n    const roundFactor = 100000\n    return Math.round(number * roundFactor) / roundFactor\n  }\n}\n\n/**\n * Geocoder implementation for the Pelias geocoder.\n * See https://pelias.io\n *\n * This is exported for testing purposes only.\n *\n * @extends Geocoder\n */\nexport class PeliasGeocoder extends Geocoder {\n  /**\n   * Generate an autocomplete query specifically for the Pelias API. The\n   * `sources` parameter is a Pelias-specific option.\n   */\n  getAutocompleteQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint, sources} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      // explicitly send over null for sources if provided sources is not truthy\n      // in order to avoid default isomorphic-mapzen-search sources form being\n      // applied\n      sources: sources || null,\n      url: baseUrl ? `${baseUrl}/autocomplete` : undefined,\n      ...query\n    }\n  }\n\n  /**\n   * Generate a search query specifically for the Pelias API. The\n   * `sources` parameter is a Pelias-specific option.\n   */\n  getSearchQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint, sources} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      // explicitly send over null for sources if provided sources is not truthy\n      // in order to avoid default isomorphic-mapzen-search sources form being\n      // applied\n      sources: sources || null,\n      url: baseUrl ? `${baseUrl}/search` : undefined,\n      format: false, // keep as returned GeoJSON,\n      ...query\n    }\n  }\n\n  /**\n   * Rewrite the response into an application-specific data format using the\n   * first feature returned from the geocoder.\n   */\n  rewriteReverseResponse (response) {\n    const { 'point.lat': lat, 'point.lon': lon } = response.isomorphicMapzenSearchQuery\n    return {\n      lat,\n      lon,\n      name: response[0].address\n    }\n  }\n}\n\n// Create a memoized getter to avoid recreating new geocoders each time.\nconst getGeocoder = memoize(geocoderConfig => {\n  if (!geocoderConfig || !geocoderConfig.type) {\n    return new NoApiGeocoder()\n  }\n  const {type} = geocoderConfig\n  switch (type) {\n    case 'ARCGIS':\n      return new ArcGISGeocoder(arcgis, geocoderConfig)\n    case 'PELIAS':\n      return new PeliasGeocoder(pelias, geocoderConfig)\n    default:\n      console.error(`Unkown geocoder type: \"${type}\". Using NoApiGeocoder.`)\n      return new NoApiGeocoder()\n  }\n})\n\nexport default getGeocoder\n"]}