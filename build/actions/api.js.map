{"version":3,"sources":["api.js"],"names":["fetch","require","nonRealtimeRoutingResponse","routingRequest","routingResponse","routingError","toggleTracking","rememberSearch","forgetSearch","formatRecentPlace","place","type","icon","id","timestamp","Date","getTime","formatRecentSearch","url","otpState","query","currentQuery","isStoredPlace","indexOf","getActiveItinerary","activeItinerary","routingType","urlParams","searches","Object","keys","length","ui_activeItinerary","routingQuery","searchId","dispatch","getState","otp","isNewSearch","console","warn","constructRoutingQuery","then","getJsonAndCheckResponse","json","response","user","trackRecent","from","to","location","catch","error","params","ui_activeSearch","updateOtpUrlParams","res","status","Error","ignoreRealtimeUpdates","config","rt","routingTypes","find","key","api","planEndpoint","host","port","path","getRoutingParams","qs","stringify","isItinerary","queryParams","filter","qp","name","applicable","forEach","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","date","OTP_API_DATE_FORMAT","isValid","timeValid","time","OTP_API_TIME_FORMAT","mode","includes","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","parkAndRideError","parkAndRideResponse","parkAndRideQuery","endpoint","map","join","createQueryAction","bikeRentalError","bikeRentalResponse","bikeRentalQuery","carRentalResponse","carRentalError","carRentalQuery","vehicleRentalResponse","vehicleRentalError","vehicleRentalQuery","findStopResponse","findStopError","findStop","stopId","serviceId","postprocess","payload","findRoutesAtStop","findStopTimesForStop","noThrottle","findTripResponse","findTripError","findTrip","tripId","findStopsForTrip","findStopTimesForTrip","findGeometryForTrip","findStopsForTripResponse","findStopsForTripError","rewritePayload","stops","findStopTimesForTripResponse","findStopTimesForTripError","stopTimes","findGeometryForTripResponse","findGeometryForTripError","geometry","findStopTimesForStopResponse","findStopTimesForStopError","otherParams","nowInSeconds","Math","floor","findRoutesResponse","findRoutesError","findRoutes","routes","rte","findPatternsForRouteResponse","findPatternsForRouteError","findRouteResponse","findRouteError","findRoute","routeId","findPatternsForRoute","patterns","ptn","findGeometryForPattern","patternId","findGeometryForPatternResponse","findGeometryForPatternError","transportationNetworkCompanyEtaResponse","transportationNetworkCompanyEtaError","getTransportationNetworkCompanyEtaEstimate","companies","estimates","transportationNetworkCompanyRideResponse","transportationNetworkCompanyRideError","getTransportationNetworkCompanyRideEstimate","company","rideType","rideEstimate","receivedNearbyStopsResponse","receivedNearbyStopsError","findNearbyStops","radius","stop","distance","latitude","lat","longitude","lon","sort","a","b","max","slice","receivedRoutesAtStopResponse","receivedRoutesAtStopError","receivedStopsWithinBBoxResponse","receivedStopsWithinBBoxError","findStopsWithinBBox","clearStops","throttledUrls","now","TEN_SECONDS","window","setInterval","responseAction","errorAction","options","alternateTransitIndex","services","log","apiRoot","throttleKey","fetchOptions","setUrlSearch","replaceCurrent","base","router","pathname","otpParams"],"mappings":"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","sourcesContent":["/* globals fetch */\nimport { push, replace } from 'connected-react-router'\nimport hash from 'object-hash'\nimport { createAction } from 'redux-actions'\nimport qs from 'qs'\nimport moment from 'moment'\nimport haversine from 'haversine'\n\nimport { rememberPlace } from './map'\nimport { hasCar } from '../util/itinerary'\nimport { getTripOptionsFromQuery, getUrlParams } from '../util/query'\nimport queryParams from '../util/query-params'\nimport { getStopViewerConfig, queryIsValid } from '../util/state'\nimport { randId } from '../util/storage'\nimport { OTP_API_DATE_FORMAT, OTP_API_TIME_FORMAT } from '../util/time'\nif (typeof (fetch) === 'undefined') require('isomorphic-fetch')\n\n// Generic API actions\n\nexport const nonRealtimeRoutingResponse = createAction('NON_REALTIME_ROUTING_RESPONSE')\nexport const routingRequest = createAction('ROUTING_REQUEST')\nexport const routingResponse = createAction('ROUTING_RESPONSE')\nexport const routingError = createAction('ROUTING_ERROR')\nexport const toggleTracking = createAction('TOGGLE_TRACKING')\nexport const rememberSearch = createAction('REMEMBER_SEARCH')\nexport const forgetSearch = createAction('FORGET_SEARCH')\n\nfunction formatRecentPlace (place) {\n  return {\n    ...place,\n    type: 'recent',\n    icon: 'clock-o',\n    id: `recent-${randId()}`,\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction formatRecentSearch (url, otpState) {\n  return {\n    query: getTripOptionsFromQuery(otpState.currentQuery, true),\n    url,\n    id: randId(),\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction isStoredPlace (place) {\n  return ['home', 'work', 'suggested', 'stop'].indexOf(place.type) !== -1\n}\n\n/**\n * Compute the initial activeItinerary. If this is the first search of\n * session (i.e. searches lookup is empty/null) AND an activeItinerary ID\n * is specified in URL parameters, use that ID. Otherwise, use null/0.\n */\nfunction getActiveItinerary (otpState) {\n  let activeItinerary = otpState.currentQuery.routingType === 'ITINERARY' ? 0 : null\n  // We cannot use window.history.state here to check for the active\n  // itinerary param because it is unreliable in some states (e.g.,\n  // when the print layout component first loads).\n  const urlParams = getUrlParams()\n  if (\n    (!otpState.searches || Object.keys(otpState.searches).length === 0) &&\n    urlParams.ui_activeItinerary\n  ) {\n    activeItinerary = +urlParams.ui_activeItinerary\n  }\n  return activeItinerary\n}\n\n/**\n * Send a routing query to the OTP backend.\n *\n * NOTE: We need a random ID so that when a user reloads the page (clearing the\n * state), performs searches, and presses back to load previous searches\n * that are no longer contained in the state we don't confuse the search IDs\n * with search IDs from the new session. If we were to use sequential numbers\n * as IDs, we would run into this problem.\n */\nexport function routingQuery (searchId = null) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    const isNewSearch = !searchId\n    if (isNewSearch) searchId = randId()\n    const routingType = otpState.currentQuery.routingType\n    // Don't permit a routing query if the query is invalid\n    if (!queryIsValid(otpState)) {\n      console.warn('Query is invalid. Aborting routing query', otpState.currentQuery)\n      return\n    }\n    const activeItinerary = getActiveItinerary(otpState)\n    dispatch(routingRequest({ activeItinerary, routingType, searchId }))\n\n    // fetch a realtime route\n    const query = constructRoutingQuery(otpState)\n    fetch(query)\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        dispatch(routingResponse({ response: json, searchId }))\n        // If tracking is enabled, store locations and search after successful\n        // search is completed.\n        if (otpState.user.trackRecent) {\n          const { from, to } = otpState.currentQuery\n          if (!isStoredPlace(from)) {\n            dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(from) }))\n          }\n          if (!isStoredPlace(to)) {\n            dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(to) }))\n          }\n          dispatch(rememberSearch(formatRecentSearch(query, otpState)))\n        }\n      })\n      .catch(error => {\n        dispatch(routingError({ error, searchId }))\n      })\n    // Update OTP URL params if a new search. In other words, if we're\n    // performing a search based on query params taken from the URL after a back\n    // button press, we don't need to update the OTP URL.\n    // TODO: For old searches that we are re-running, should we be **replacing**\n    //  the URL params here (instead of **pushing** a new path to history like\n    //  what currently happens in updateOtpUrlParams)? That way we could ensure\n    //  that the path absolutely accurately reflects the app state.\n    const params = getUrlParams()\n    if (isNewSearch || params.ui_activeSearch !== searchId) {\n      dispatch(updateOtpUrlParams(otpState, searchId))\n    }\n    // also fetch a non-realtime route\n    fetch(constructRoutingQuery(otpState, true))\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        // FIXME: This is only performed when ignoring realtimeupdates currently, just\n        // to ensure it is not repeated twice.\n        dispatch(nonRealtimeRoutingResponse({ response: json, searchId }))\n      })\n      .catch(error => {\n        console.error(error)\n        // do nothing\n      })\n  }\n}\n\nfunction getJsonAndCheckResponse (res) {\n  if (res.status >= 400) {\n    const error = new Error('Received error from server')\n    error.response = res\n    throw error\n  }\n  return res.json()\n}\n\nfunction constructRoutingQuery (otpState, ignoreRealtimeUpdates) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  // Check for routingType-specific API config; if none, use default API\n  const rt = config.routingTypes && config.routingTypes.find(rt => rt.key === routingType)\n  const api = (rt && rt.api) || config.api\n  const planEndpoint = `${api.host}${api.port\n    ? ':' + api.port\n    : ''}${api.path}/plan`\n  const params = getRoutingParams(otpState, ignoreRealtimeUpdates)\n  return `${planEndpoint}?${qs.stringify(params)}`\n}\n\nfunction getRoutingParams (otpState, ignoreRealtimeUpdates) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  const isItinerary = routingType === 'ITINERARY'\n  let params = {}\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== 'function' || qp.applicable(currentQuery, config))\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      )\n    })\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === 'boolean') {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid()\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid()\n\n    if (!dateValid || !timeValid) {\n      delete params.time\n      delete params.date\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes('CAR_HAIL') || params.mode.includes('CAR_RENT'))\n    ) {\n      params.minTransitDistance = '50%'\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes('CAR_RENT')) {\n      params.onlyTransitTrips = true\n    }\n\n  // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(params.startTime, OTP_API_TIME_FORMAT).isValid()\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid()\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid\n      delete params.endTimeValid\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += ',WALK'\n  }\n\n  return params\n}\n\n// Park and Ride location query\n\nexport const parkAndRideError = createAction('PARK_AND_RIDE_ERROR')\nexport const parkAndRideResponse = createAction('PARK_AND_RIDE_RESPONSE')\n\nexport function parkAndRideQuery (params) {\n  let endpoint = 'park_and_ride'\n  if (params && Object.keys(params).length > 0) {\n    endpoint += '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&')\n  }\n  return createQueryAction(endpoint, parkAndRideResponse, parkAndRideError)\n}\n\n// bike rental station query\n\nexport const bikeRentalError = createAction('BIKE_RENTAL_ERROR')\nexport const bikeRentalResponse = createAction('BIKE_RENTAL_RESPONSE')\n\nexport function bikeRentalQuery (params) {\n  return createQueryAction('bike_rental', bikeRentalResponse, bikeRentalError)\n}\n\n// Car rental (e.g. car2go) locations lookup query\n\nexport const carRentalResponse = createAction('CAR_RENTAL_RESPONSE')\nexport const carRentalError = createAction('CAR_RENTAL_ERROR')\n\nexport function carRentalQuery (params) {\n  return createQueryAction('car_rental', carRentalResponse, carRentalError)\n}\n\n// Vehicle rental locations lookup query. For now, there are 3 seperate\n// \"vehicle\" rental endpoints - 1 for cars, 1 for bicycle rentals and another\n// for micromobility. In the future, the hope is to consolidate these 3\n// endpoints into one.\n\nexport const vehicleRentalResponse = createAction('VEHICLE_RENTAL_RESPONSE')\nexport const vehicleRentalError = createAction('VEHICLE_RENTAL_ERROR')\n\nexport function vehicleRentalQuery (params) {\n  return createQueryAction('vehicle_rental', vehicleRentalResponse, vehicleRentalError)\n}\n\n// Single stop lookup query\nconst findStopResponse = createAction('FIND_STOP_RESPONSE')\nconst findStopError = createAction('FIND_STOP_ERROR')\n\nexport function findStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}`,\n    findStopResponse,\n    findStopError,\n    {\n      serviceId: 'stops',\n      postprocess: (payload, dispatch) => {\n        dispatch(findRoutesAtStop(params.stopId))\n        dispatch(findStopTimesForStop(params))\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// TODO: Optionally substitute GraphQL queries? Note: this is not currently\n// possible because gtfsdb (the alternative transit index used by TriMet) does not\n// support GraphQL queries.\n// export function findStop (params) {\n//   const query = `\n// query stopQuery($stopId: [String]) {\n//   stops (ids: $stopId) {\n//     id: gtfsId\n//     code\n//     name\n//     url\n//     lat\n//     lon\n//     stoptimesForPatterns {\n//       pattern {\n//         id: semanticHash\n//         route {\n//           id: gtfsId\n//           longName\n//           shortName\n//           sortOrder\n//         }\n//       }\n//       stoptimes {\n//         scheduledArrival\n//         realtimeArrival\n//         arrivalDelay\n//         scheduledDeparture\n//         realtimeDeparture\n//         departureDelay\n//         timepoint\n//         realtime\n//         realtimeState\n//         serviceDay\n//         headsign\n//       }\n//     }\n//   }\n// }\n// `\n//   return createGraphQLQueryAction(\n//     query,\n//     { stopId: params.stopId },\n//     findStopResponse,\n//     findStopError,\n//     {\n//       // find stop should not be throttled since it can make quite frequent\n//       // updates when fetching stop times for a stop\n//       noThrottle: true,\n//       serviceId: 'stops',\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = []\n//         const { stoptimesForPatterns, ...stop } = payload.data.stops[0]\n//         stoptimesForPatterns.forEach(obj => {\n//           const { pattern, stoptimes: stopTimes } = obj\n//           // It's possible that not all stop times for a pattern will share the\n//           // same headsign, but this is probably a minor edge case.\n//           const headsign = stopTimes[0]\n//             ? stopTimes[0].headsign\n//             : pattern.route.longName\n//           const patternIndex = patterns.findIndex(p =>\n//             p.headsign === headsign && pattern.route.id === p.route.id)\n//           if (patternIndex === -1) {\n//             patterns.push({ ...pattern, headsign, stopTimes })\n//           } else {\n//             patterns[patternIndex].stopTimes.push(...stopTimes)\n//           }\n//         })\n//         return {\n//           ...stop,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// Single trip lookup query\n\nexport const findTripResponse = createAction('FIND_TRIP_RESPONSE')\nexport const findTripError = createAction('FIND_TRIP_ERROR')\n\nexport function findTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}`,\n    findTripResponse,\n    findTripError,\n    {\n      postprocess: (payload, dispatch) => {\n        dispatch(findStopsForTrip({tripId: params.tripId}))\n        dispatch(findStopTimesForTrip({tripId: params.tripId}))\n        dispatch(findGeometryForTrip({tripId: params.tripId}))\n      }\n    }\n  )\n}\n\n// Stops for trip query\n\nexport const findStopsForTripResponse = createAction('FIND_STOPS_FOR_TRIP_RESPONSE')\nexport const findStopsForTripError = createAction('FIND_STOPS_FOR_TRIP_ERROR')\n\nexport function findStopsForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stops`,\n    findStopsForTripResponse,\n    findStopsForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stops: payload\n        }\n      }\n    }\n  )\n}\n\n// Stop times for trip query\n\nexport const findStopTimesForTripResponse = createAction('FIND_STOP_TIMES_FOR_TRIP_RESPONSE')\nexport const findStopTimesForTripError = createAction('FIND_STOP_TIMES_FOR_TRIP_ERROR')\n\nexport function findStopTimesForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stoptimes`,\n    findStopTimesForTripResponse,\n    findStopTimesForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stopTimes: payload\n        }\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// Geometry for trip query\n\nexport const findGeometryForTripResponse = createAction('FIND_GEOMETRY_FOR_TRIP_RESPONSE')\nexport const findGeometryForTripError = createAction('FIND_GEOMETRY_FOR_TRIP_ERROR')\n\nexport function findGeometryForTrip (params) {\n  return createQueryAction(`index/trips/${params.tripId}/geometry`,\n    findGeometryForTripResponse, findGeometryForTripError,\n    (payload) => {\n      return {\n        tripId: params.tripId,\n        geometry: payload\n      }\n    }\n  )\n}\n\nconst findStopTimesForStopResponse = createAction('FIND_STOP_TIMES_FOR_STOP_RESPONSE')\nconst findStopTimesForStopError = createAction('FIND_STOP_TIMES_FOR_STOP_ERROR')\n\n/**\n * Stop times for stop query (used in stop viewer).\n */\nexport function findStopTimesForStop (params) {\n  return function (dispatch, getState) {\n    let { stopId, ...otherParams } = params\n    // If other params not provided, fall back on defaults from stop viewer config.\n    const queryParams = { ...getStopViewerConfig(getState().otp), ...otherParams }\n    // If no start time is provided, pass in the current time. Note: this is not\n    // a required param by the back end, but if a value is not provided, the\n    // time defaults to the server's time, which can make it difficult to test\n    // scenarios when you may want to use a different date/time for your local\n    // testing environment.\n    if (!queryParams.startTime) {\n      const nowInSeconds = Math.floor((new Date()).getTime() / 1000)\n      queryParams.startTime = nowInSeconds\n    }\n    dispatch(createQueryAction(\n      `index/stops/${stopId}/stoptimes?${qs.stringify(queryParams)}`,\n      findStopTimesForStopResponse,\n      findStopTimesForStopError,\n      {\n        rewritePayload: (stopTimes) => {\n          return {\n            stopId,\n            stopTimes\n          }\n        },\n        noThrottle: true\n      }\n    ))\n  }\n}\n\n// Routes lookup query\n\nconst findRoutesResponse = createAction('FIND_ROUTES_RESPONSE')\nconst findRoutesError = createAction('FIND_ROUTES_ERROR')\n\nexport function findRoutes (params) {\n  return createQueryAction(\n    'index/routes',\n    findRoutesResponse,\n    findRoutesError,\n    {\n      serviceId: 'routes',\n      rewritePayload: (payload) => {\n        const routes = {}\n        payload.forEach(rte => { routes[rte.id] = rte })\n        return routes\n      }\n    }\n  )\n}\n\n// export function findRoutes (params) {\n//   const query = `\n// {\n//   routes {\n//     id: gtfsId\n//     color\n//     longName\n//     shortName\n//     mode\n//     type\n//     desc\n//     bikesAllowed\n//     sortOrder\n//     textColor\n//     url\n//     agency {\n//       id: gtfsId\n//       name\n//       url\n//     }\n//   }\n// }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     {},\n//     findRoutesResponse,\n//     findRoutesError,\n//     {\n//       serviceId: 'routes',\n//       rewritePayload: (payload) => {\n//         const routes = {}\n//         payload.data.routes.forEach(rte => { routes[rte.id] = rte })\n//         return routes\n//       }\n//     }\n//   )\n// }\n\n// Patterns for Route lookup query\n// TODO: replace with GraphQL query for route => patterns => geometry\nconst findPatternsForRouteResponse = createAction('FIND_PATTERNS_FOR_ROUTE_RESPONSE')\nconst findPatternsForRouteError = createAction('FIND_PATTERNS_FOR_ROUTE_ERROR')\n\n// Single Route lookup query\n\nexport const findRouteResponse = createAction('FIND_ROUTE_RESPONSE')\nexport const findRouteError = createAction('FIND_ROUTE_ERROR')\n\nexport function findRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}`,\n    findRouteResponse,\n    findRouteError,\n    {\n      postprocess: (payload, dispatch) => {\n        // load patterns\n        dispatch(findPatternsForRoute({ routeId: params.routeId }))\n      },\n      noThrottle: true\n    }\n  )\n}\n\nexport function findPatternsForRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}/patterns`,\n    findPatternsForRouteResponse,\n    findPatternsForRouteError,\n    {\n      rewritePayload: (payload) => {\n        // convert pattern array to ID-mapped object\n        const patterns = {}\n        payload.forEach(ptn => { patterns[ptn.id] = ptn })\n\n        return {\n          routeId: params.routeId,\n          patterns\n        }\n      },\n      postprocess: (payload, dispatch) => {\n        // load geometry for each pattern\n        payload.forEach(ptn => {\n          dispatch(findGeometryForPattern({\n            routeId: params.routeId,\n            patternId: ptn.id\n          }))\n        })\n      }\n    }\n  )\n}\n\n// Geometry for Pattern lookup query\n\nconst findGeometryForPatternResponse = createAction('FIND_GEOMETRY_FOR_PATTERN_RESPONSE')\nconst findGeometryForPatternError = createAction('FIND_GEOMETRY_FOR_PATTERN_ERROR')\n\nexport function findGeometryForPattern (params) {\n  return createQueryAction(\n    `index/patterns/${params.patternId}/geometry`,\n    findGeometryForPatternResponse,\n    findGeometryForPatternError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          routeId: params.routeId,\n          patternId: params.patternId,\n          geometry: payload\n        }\n      }\n    }\n  )\n}\n\n// export function findRoute (params) {\n//   const query = `\n//   query routeQuery($routeId: [String]) {\n//     routes (ids: $routeId) {\n//       id: gtfsId\n//       patterns {\n//         id: semanticHash\n//         directionId\n//         headsign\n//         name\n//         semanticHash\n//         geometry {\n//           lat\n//           lon\n//         }\n//       }\n//     }\n//   }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     { routeId: params.routeId },\n//     findPatternsForRouteResponse,\n//     findPatternsForRouteError,\n//     {\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = {}\n//         payload.data.routes[0].patterns.forEach(ptn => {\n//           patterns[ptn.id] = {\n//             routeId: params.routeId,\n//             patternId: ptn.id,\n//             geometry: ptn.geometry\n//           }\n//         })\n//\n//         return {\n//           routeId: params.routeId,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// TNC ETA estimate lookup query\n\nexport const transportationNetworkCompanyEtaResponse = createAction('TNC_ETA_RESPONSE')\nexport const transportationNetworkCompanyEtaError = createAction('TNC_ETA_ERROR')\n\nexport function getTransportationNetworkCompanyEtaEstimate (params) {\n  const {companies, from} = params\n  return createQueryAction(\n    `transportation_network_company/eta_estimate?${qs.stringify({\n      companies,\n      from\n    })}`, // endpoint\n    transportationNetworkCompanyEtaResponse, // responseAction\n    transportationNetworkCompanyEtaError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          from,\n          estimates: payload.estimates\n        }\n      }\n    }\n  )\n}\n\n// TNC ride estimate lookup query\n\nexport const transportationNetworkCompanyRideResponse = createAction('TNC_RIDE_RESPONSE')\nexport const transportationNetworkCompanyRideError = createAction('TNC_RIDE_ERROR')\n\nexport function getTransportationNetworkCompanyRideEstimate (params) {\n  const {company, from, rideType, to} = params\n  return createQueryAction(\n    `transportation_network_company/ride_estimate?${qs.stringify({\n      company,\n      from,\n      rideType,\n      to\n    })}`, // endpoint\n    transportationNetworkCompanyRideResponse, // responseAction\n    transportationNetworkCompanyRideError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          company,\n          from,\n          rideEstimate: payload.rideEstimate,\n          to\n        }\n      }\n    }\n  )\n}\n\n// Nearby Stops Query\n\nconst receivedNearbyStopsResponse = createAction('NEARBY_STOPS_RESPONSE')\nconst receivedNearbyStopsError = createAction('NEARBY_STOPS_ERROR')\n\nexport function findNearbyStops (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify({radius: 1000, ...params})}`,\n    receivedNearbyStopsResponse,\n    receivedNearbyStopsError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => {\n        if (stops) {\n          // Sort the stops by proximity\n          stops.forEach(stop => {\n            stop.distance = haversine(\n              { latitude: params.lat, longitude: params.lon },\n              { latitude: stop.lat, longitude: stop.lon }\n            )\n          })\n          stops.sort((a, b) => { return a.distance - b.distance })\n          if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        }\n        return {stops}\n      },\n      // retrieve routes for each stop\n      postprocess: (stops, dispatch, getState) => {\n        if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        stops.forEach(stop => dispatch(findRoutesAtStop(stop.id)))\n      }\n    }\n  )\n}\n\n// Routes at Stop query\n\nconst receivedRoutesAtStopResponse = createAction('ROUTES_AT_STOP_RESPONSE')\nconst receivedRoutesAtStopError = createAction('ROUTES_AT_STOP_ERROR')\n\nexport function findRoutesAtStop (stopId) {\n  return createQueryAction(\n    `index/stops/${stopId}/routes`,\n    receivedRoutesAtStopResponse,\n    receivedRoutesAtStopError,\n    {\n      serviceId: 'stops/routes',\n      rewritePayload: routes => ({ stopId, routes }),\n      noThrottle: true\n    }\n  )\n}\n\n// Stops within Bounding Box Query\n\nconst receivedStopsWithinBBoxResponse = createAction('STOPS_WITHIN_BBOX_RESPONSE')\nconst receivedStopsWithinBBoxError = createAction('STOPS_WITHIN_BBOX_ERROR')\n\nexport function findStopsWithinBBox (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify(params)}`,\n    receivedStopsWithinBBoxResponse,\n    receivedStopsWithinBBoxError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => ({stops})\n    }\n  )\n}\n\nexport const clearStops = createAction('CLEAR_STOPS_OVERLAY')\n\nconst throttledUrls = {}\n\nfunction now () {\n  return (new Date()).getTime()\n}\n\nconst TEN_SECONDS = 10000\n\n// automatically clear throttled urls older than 10 seconds\nwindow.setInterval(() => {\n  Object.keys(throttledUrls).forEach(key => {\n    if (throttledUrls[key] < now() - TEN_SECONDS) {\n      delete throttledUrls[key]\n    }\n  })\n}, 1000)\n\n/**\n * Generic helper for constructing API queries. Automatically throttles queries\n * to url to no more than once per 10 seconds.\n *\n * @param {string} endpoint - The API endpoint path (does not include\n *   '../otp/routers/router_id/')\n * @param {Function} responseAction - Action to dispatch on a successful API\n *   response. Accepts payload object parameter.\n * @param {Function} errorAction - Function to invoke on API error response.\n *   Accepts error object parameter.\n * @param {Options} options - Any of the following optional settings:\n *   - rewritePayload: Function to be invoked to modify payload before being\n *       passed to responseAction. Accepts and returns payload object.\n *   - postprocess: Function to be invoked after responseAction is invoked.\n *       Accepts payload, dispatch, getState parameters.\n *   - serviceId: identifier for TransitIndex service used in\n *       alternateTransitIndex configuration.\n *   - fetchOptions: fetch options (e.g., method, body, headers).\n */\n\nfunction createQueryAction (endpoint, responseAction, errorAction, options = {}) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    let url\n    if (options.serviceId && otpState.config.alternateTransitIndex &&\n      otpState.config.alternateTransitIndex.services.includes(options.serviceId)\n    ) {\n      console.log('Using alt service for ' + options.serviceId)\n      url = otpState.config.alternateTransitIndex.apiRoot + endpoint\n    } else {\n      const api = otpState.config.api\n      url = `${api.host}${api.port ? ':' + api.port : ''}${api.path}/${endpoint}`\n    }\n\n    if (!options.noThrottle) {\n      // don't make a request to a URL that has already seen the same request\n      // within the last 10 seconds\n      const throttleKey = options.fetchOptions\n        ? `${url}-${hash(options.fetchOptions)}`\n        : url\n      if (throttledUrls[throttleKey] && throttledUrls[throttleKey] > now() - TEN_SECONDS) {\n        // URL already had a request within last 10 seconds, warn and exit\n        console.warn(`Request throttled for url: ${url}`)\n        return\n      } else {\n        throttledUrls[throttleKey] = now()\n      }\n    }\n    let payload\n    try {\n      const response = await fetch(url, options.fetchOptions)\n      if (response.status >= 400) {\n        const error = new Error('Received error from server')\n        error.response = response\n        throw error\n      }\n      payload = await response.json()\n    } catch (err) {\n      return dispatch(errorAction(err))\n    }\n\n    if (typeof options.rewritePayload === 'function') {\n      dispatch(responseAction(options.rewritePayload(payload)))\n    } else {\n      dispatch(responseAction(payload))\n    }\n\n    if (typeof options.postprocess === 'function') {\n      options.postprocess(payload, dispatch, getState)\n    }\n  }\n}\n\n// TODO: Determine how we might be able to use GraphQL with the alternative\n// transit index. Currently this is not easily possible because the alternative\n// transit index does not have support for GraphQL and handling both Rest and\n// GraphQL queries could introduce potential difficulties for maintainers.\n// function createGraphQLQueryAction (query, variables, responseAction, errorAction, options) {\n//   const endpoint = `index/graphql`\n//   const fetchOptions = {\n//     method: 'POST',\n//     body: JSON.stringify({ query, variables }),\n//     headers: { 'Content-Type': 'application/json' }\n//   }\n//   return createQueryAction(\n//     endpoint,\n//     responseAction,\n//     errorAction,\n//     { ...options, fetchOptions }\n//   )\n// }\n\n/**\n * Update the browser/URL history with new parameters\n * NOTE: This has not been tested for profile-based journeys.\n */\nexport function setUrlSearch (params, replaceCurrent = false) {\n  return function (dispatch, getState) {\n    const base = getState().router.location.pathname\n    const path = `${base}?${qs.stringify(params)}`\n    if (replaceCurrent) dispatch(replace(path))\n    else dispatch(push(path))\n  }\n}\n\n/**\n * Update the OTP Query parameters in the URL and ensure that the active search\n * is set correctly. Leaves any other existing URL parameters (e.g., UI) unchanged.\n */\nexport function updateOtpUrlParams (otpState, searchId) {\n  const otpParams = getRoutingParams(otpState, true)\n  return function (dispatch, getState) {\n    const params = {}\n    // Get all OTP-specific params, which will be retained unchanged in the URL\n    const urlParams = getUrlParams()\n    Object.keys(urlParams)\n      .filter(key => key.indexOf('_') !== -1)\n      .forEach(key => { params[key] = urlParams[key] })\n    params.ui_activeSearch = searchId\n    // Assumes this is a new search and the active itinerary should be reset.\n    params.ui_activeItinerary = 0\n    // Merge in the provided OTP params and update the URL\n    dispatch(setUrlSearch(Object.assign(params, otpParams)))\n  }\n}\n"]}