{"version":3,"sources":["responsive-webapp.js"],"names":["ResponsiveWebapp","prevProps","props","currentPosition","location","query","title","document","urlParams","newSearchId","ui_activeSearch","replanningTrip","activeSearchId","formChanged","error","coords","pt","lat","latitude","lon","longitude","from","setLocationToCurrent","type","setMapCenter","initZoomOnLocate","setMapZoom","zoom","pathname","matchContentToUrl","window","addEventListener","handleBackButtonPress","getCurrentPosition","navigator","geolocation","watchPosition","position","receivedPositionResponse","console","log","enableHighAccuracy","search","parseUrlQueryString","removeEventListener","desktopView","mobileView","Component","PropTypes","element","number","object","mapStateToProps","state","ownProps","activeItinerary","otp","currentQuery","searches","mobileScreen","ui","config","map","modeGroups","mapDispatchToProps","history","WebappWithRouter","RouterWrapper","routerConfig","basename","routerProps","mapStateToWrapperProps","reactRouter"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport isEqual from 'lodash.isequal'\nimport { Route, Switch, withRouter } from 'react-router'\nimport { createHashHistory } from 'history'\nimport { ConnectedRouter } from 'connected-react-router'\n\nimport PrintLayout from './print-layout'\nimport { setMapCenter, setMapZoom } from '../../actions/config'\nimport { setLocationToCurrent } from '../../actions/map'\nimport { getCurrentPosition, receivedPositionResponse } from '../../actions/location'\nimport { formChanged, parseUrlQueryString } from '../../actions/form'\nimport { handleBackButtonPress, matchContentToUrl } from '../../actions/ui'\nimport { getUrlParams } from '../../util/query'\nimport { getTitle, isMobile } from '../../util/ui'\nimport { getActiveItinerary } from '../../util/state'\n\nclass ResponsiveWebapp extends Component {\n  static propTypes = {\n    desktopView: PropTypes.element,\n    initZoomOnLocate: PropTypes.number,\n    mobileView: PropTypes.element,\n    query: PropTypes.object\n  }\n\n  /** Lifecycle methods **/\n\n  componentDidUpdate (prevProps) {\n    const { currentPosition, location, query, title } = this.props\n    document.title = title\n    const urlParams = getUrlParams()\n    const newSearchId = urlParams.ui_activeSearch\n    // Determine if trip is being replanned by checking the active search ID\n    // against the ID found in the URL params. If they are different, a new one\n    // has been routed to (see handleBackButtonPress) and there is no need to\n    // trigger a form change because necessarily the query will be different\n    // from the previous query.\n    const replanningTrip = newSearchId && this.props.activeSearchId && newSearchId !== this.props.activeSearchId\n    if (!isEqual(prevProps.query, query) && !replanningTrip) {\n      // Trigger on form change action if previous query is different from\n      // current one AND trip is not being replanned already. This will\n      // determine whether a search needs to be made, the mobile view needs\n      // updating, etc.\n      this.props.formChanged(prevProps.query, query)\n    }\n\n    // check if device position changed (typically only set once, on initial page load)\n    if (currentPosition !== prevProps.currentPosition) {\n      if (currentPosition.error || !currentPosition.coords) return\n      const pt = {\n        lat: currentPosition.coords.latitude,\n        lon: currentPosition.coords.longitude\n      }\n\n      // if in mobile mode and from field is not set, use current location as from and recenter map\n      if (isMobile() && this.props.query.from === null) {\n        this.props.setLocationToCurrent({ type: 'from' })\n        this.props.setMapCenter(pt)\n        if (this.props.initZoomOnLocate) {\n          this.props.setMapZoom({ zoom: this.props.initZoomOnLocate })\n        }\n      }\n    }\n    // If the path changes (e.g., via a back button press) check whether the\n    // main content needs to switch between, for example, a viewer and a search.\n    if (!isEqual(location.pathname, prevProps.location.pathname)) {\n      // console.log('url changed to', location.pathname)\n      this.props.matchContentToUrl(location)\n    }\n    // Check for change between ITINERARY and PROFILE routingTypes\n    // TODO: restore this for profile mode\n    /* if (query.routingType !== nextProps.query.routingType) {\n      let queryModes = nextProps.query.mode.split(',')\n      // If we are entering 'ITINERARY' mode, ensure that one and only one access mode is selected\n      if (nextProps.query.routingType === 'ITINERARY') {\n        queryModes = ensureSingleAccessMode(queryModes)\n        this.props.setQueryParam({ mode: queryModes.join(',') })\n      }\n      // If we are entering 'PROFILE' mode, ensure that CAR_HAIL is not selected\n      // TODO: make this more generic, i.e. introduce concept of mode->routingType permissions\n      if (nextProps.query.routingType === 'ITINERARY') {\n        queryModes = queryModes.filter(mode => mode !== 'CAR_HAIL')\n        this.props.setQueryParam({ mode: queryModes.join(',') })\n      }\n    } */\n  }\n\n  componentDidMount () {\n    // Add on back button press behavior.\n    window.addEventListener('popstate', this.props.handleBackButtonPress)\n    const { location, title } = this.props\n    document.title = title\n    if (isMobile()) {\n      // If on mobile browser, check position on load\n      this.props.getCurrentPosition()\n\n      // Also, watch for changes in position on mobile\n      navigator.geolocation.watchPosition(\n        // On success\n        position => { this.props.receivedPositionResponse({ position }) },\n        // On error\n        error => { console.log('error in watchPosition', error) },\n        // Options\n        { enableHighAccuracy: true }\n      )\n    }\n\n    if (location && location.search) {\n      // Set search params and plan trip if routing enabled and a query exists\n      // in the URL.\n      this.props.parseUrlQueryString()\n    }\n    // Handle routing to a specific part of the app (e.g. stop viewer) on page\n    // load.\n    this.props.matchContentToUrl(this.props.location)\n  }\n\n  componentWillUnmount () {\n    // Remove on back button press listener.\n    window.removeEventListener('popstate')\n  }\n\n  render () {\n    const { desktopView, mobileView } = this.props\n    return isMobile() ? mobileView : desktopView\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const title = getTitle(state)\n  return {\n    activeItinerary: getActiveItinerary(state.otp),\n    activeSearchId: state.otp.activeSearchId,\n    currentPosition: state.otp.location.currentPosition,\n    query: state.otp.currentQuery,\n    searches: state.otp.searches,\n    mobileScreen: state.otp.ui.mobileScreen,\n    initZoomOnLocate: state.otp.config.map && state.otp.config.map.initZoomOnLocate,\n    modeGroups: state.otp.config.modeGroups,\n    title\n  }\n}\n\nconst mapDispatchToProps = {\n  formChanged,\n  getCurrentPosition,\n  handleBackButtonPress,\n  matchContentToUrl,\n  parseUrlQueryString,\n  receivedPositionResponse,\n  setLocationToCurrent,\n  setMapCenter,\n  setMapZoom\n}\n\nconst history = createHashHistory()\n\nconst WebappWithRouter = withRouter(\n  connect(mapStateToProps, mapDispatchToProps)(ResponsiveWebapp)\n)\n\nclass RouterWrapper extends Component {\n  render () {\n    const { routerConfig } = this.props\n    return (\n      <ConnectedRouter\n        basename={routerConfig && routerConfig.basename}\n        history={history}>\n        <div>\n          <Switch>\n            <Route\n              exact\n              path={[\n                // App root\n                '/',\n                // Load app with preset lat/lon/zoom and optional router\n                // NOTE: All params will be cast to :id in matchContentToUrl due\n                // to a quirk with react-router.\n                // https://github.com/ReactTraining/react-router/issues/5870#issuecomment-394194338\n                '/@/:latLonZoomRouter',\n                '/start/:latLonZoomRouter',\n                // Route viewer (and route ID).\n                '/route',\n                '/route/:id',\n                // Stop viewer (and stop ID).\n                '/stop',\n                '/stop/:id'\n              ]}\n              render={() => <WebappWithRouter {...this.props} />}\n            />\n            <Route\n              path='/print'\n              component={(routerProps) => {\n                // combine the router props with the other props that get\n                // passed to the exported component. This way it's possible for\n                // the PrintLayout component to receive the custom icons prop.\n                const props = { ...this.props, ...routerProps }\n                return <PrintLayout {...props} />\n              }}\n            />\n            {/* For any other route, simply return the web app. */}\n            <Route\n              render={() => <WebappWithRouter {...this.props} />}\n            />\n          </Switch>\n        </div>\n      </ConnectedRouter>\n    )\n  }\n}\nconst mapStateToWrapperProps = (state, ownProps) => ({ routerConfig: state.otp.config.reactRouter })\nexport default connect(mapStateToWrapperProps)(RouterWrapper)\n"]}