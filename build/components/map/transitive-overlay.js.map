{"version":3,"sources":["transitive-overlay.js"],"names":["require","checkHiPPI","canvas","window","devicePixelRatio","PIXEL_RATIO","style","width","height","context","getContext","scale","zoomFactors","minScale","gridCellSize","internalVertexFactor","angleConstraint","mergeVertexThreshold","useGeographicRendering","TransitiveCanvasOverlay","map","LEAFLET","L","canvasLayer","delegate","addTo","nextProps","_transitive","transitiveData","props","updateData","render","_updateBoundsAndRender","routingType","activeItinerary","focusJourney","journeys","journey_id","mapBounds","getBounds","Transitive","data","initialBounds","getWest","getSouth","getEast","getNorth","zoomEnabled","autoResize","styles","display","console","log","setDisplayBounds","info","_initTransitive","mapSize","getSize","_lastMapSize","x","y","setDimensions","setCanvas","coords","fromProps","toProps","MapLayer","PropTypes","object","mapStateToProps","state","ownProps","activeSearch","otp","query","response","plan","itins","mapDispatchToProps"],"mappings":"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","sourcesContent":["import { PropTypes } from 'react'\nimport { MapLayer } from 'react-leaflet'\nimport L from 'leaflet'\nimport { connect } from 'react-redux'\nimport Transitive from 'transitive-js'\nimport isEqual from 'lodash.isequal'\n\nimport { getActiveSearch, getActiveItineraries } from '../../util/state'\nimport { itineraryToTransitive } from '../../util/map'\n\nrequire('./leaflet-canvas-layer')\n\n// TODO: move to util?\nfunction checkHiPPI (canvas) {\n  if (window.devicePixelRatio > 1) {\n    const PIXEL_RATIO = 2\n    canvas.style.width = canvas.width + 'px'\n    canvas.style.height = canvas.height + 'px'\n\n    canvas.width *= PIXEL_RATIO\n    canvas.height *= PIXEL_RATIO\n\n    var context = canvas.getContext('2d')\n    context.scale(PIXEL_RATIO, PIXEL_RATIO)\n  }\n}\n\nconst zoomFactors = [{\n  minScale: 0,\n  gridCellSize: 0,\n  internalVertexFactor: 0,\n  angleConstraint: 5,\n  mergeVertexThreshold: 0,\n  useGeographicRendering: true\n}]\n\nclass TransitiveCanvasOverlay extends MapLayer {\n  static propTypes = {\n    transitiveData: PropTypes.object\n  }\n\n  // React Lifecycle Methods\n\n  componentDidMount () {\n    const map = this.context.map\n    // FIXME: hack because L is undefined for some reason\n    const LEAFLET = L || window.L\n    LEAFLET.canvasLayer()\n      .delegate(this) // -- if we do not inherit from L.CanvasLayer  we can setup a delegate to receive events from L.CanvasLayer\n      .addTo(map)\n  }\n\n  componentWillReceiveProps (nextProps) {\n    // Check if we received new transitive data\n    if (this._transitive && !isEqual(nextProps.transitiveData, this.props.transitiveData)) {\n      this._transitive.updateData(nextProps.transitiveData)\n      if (!nextProps.transitiveData) this._transitive.render()\n      else this._updateBoundsAndRender()\n    }\n\n    if ( // this block only applies for profile trips where active option changed\n      nextProps.routingType === 'PROFILE' &&\n      nextProps.activeItinerary !== this.props.activeItinerary\n    ) {\n      if (nextProps.activeItinerary == null) { // no option selected; clear focus\n        this._transitive.focusJourney(null)\n        this._transitive.render()\n      } else if (nextProps.transitiveData) {\n        this._transitive.focusJourney(nextProps.transitiveData.journeys[nextProps.activeItinerary].journey_id)\n        this._transitive.render()\n      }\n    }\n  }\n\n  componentWillUnmount () {\n    if (this._transitive) {\n      this._transitive.updateData(null)\n      this._transitive.render()\n    }\n  }\n\n  // Internal Methods\n\n  _initTransitive (canvas) {\n    const map = this.context.map\n\n    // set up the transitive instance\n    const mapBounds = map.getBounds()\n    this._transitive = new Transitive({\n      data: this.props.transitiveData,\n      initialBounds: [[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]],\n      zoomEnabled: false,\n      autoResize: false,\n      styles: require('./transitive-styles'),\n      zoomFactors,\n      display: 'canvas',\n      canvas\n    })\n\n    checkHiPPI(canvas)\n\n    // the initial map draw\n    this._updateBoundsAndRender()\n  }\n\n  _updateBoundsAndRender () {\n    if (!this._transitive) {\n      console.log('WARNING: Transitive object not set in transitive-canvas-overlay')\n      return\n    }\n\n    const mapBounds = this.context.map.getBounds()\n    this._transitive.setDisplayBounds([[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]])\n    this._transitive.render()\n  }\n\n  // Leaflet Layer API Methods\n\n  onDrawLayer (info) {\n    if (!this._transitive) this._initTransitive(info.canvas)\n\n    const mapSize = this.context.map.getSize()\n    if (\n      this._lastMapSize && (\n        mapSize.x !== this._lastMapSize.x ||\n        mapSize.y !== this._lastMapSize.y\n      )\n    ) {\n      const canvas = info.canvas\n      checkHiPPI(canvas)\n      this._transitive.display.setDimensions(mapSize.x, mapSize.y)\n      this._transitive.display.setCanvas(canvas)\n    }\n\n    this._updateBoundsAndRender()\n\n    this._lastMapSize = this.context.map.getSize()\n  }\n\n  createTile (coords) {\n  }\n\n  createLeafletElement (props) {\n  }\n\n  updateLeafletElement (fromProps, toProps) {\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeSearch = getActiveSearch(state.otp)\n  let transitiveData = null\n  if (activeSearch && activeSearch.query.routingType === 'ITINERARY' && activeSearch.response && activeSearch.response.plan) {\n    const itins = getActiveItineraries(state.otp)\n    // TODO: prevent itineraryToTransitive() from being called more than needed\n    transitiveData = itineraryToTransitive(itins[activeSearch.activeItinerary])\n  } else if (activeSearch && activeSearch.response && activeSearch.response.otp) {\n    transitiveData = activeSearch.response.otp\n  }\n\n  return {\n    transitiveData,\n    activeItinerary: activeSearch && activeSearch.activeItinerary,\n    routingType: activeSearch && activeSearch.query && activeSearch.query.routingType\n  }\n}\n\nconst mapDispatchToProps = {\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TransitiveCanvasOverlay)\n"]}